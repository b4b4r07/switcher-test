#!/bin/zsh

__import "core/core"
__import "print/print"
__import "print/logger"
__import "job/spinner"

trap '__spin_unlock; trap - SIGINT' SIGINT

local    line filter is_select=false
local -i cnt=0 max=0 ret=0
local -a args
local -a queue
local -i queue_max=$ZPLUG_THREADS
local -F SECONDS=0

local -i frozen_lock=0

case "$1" in
    --self)
        __self__
        return $status
        ;;
    --select)
        is_select=true; shift
        ;;
    -*|--*)
        __die "$1: Unknown option\n"
        return 1
        ;;
esac

# Initialize
{
    filter="$(__get_filter "$ZPLUG_FILTER")"
    if $is_select; then
        args=(${(@f)"$(echo "${(Fk)zplugs}" | eval "$filter")"})
    else
        args=(${(u)${@:gs:@::}})
    fi

    if (( $#args == 0 )); then
        __list__
        return $status
    fi

    for line in "${args[@]}"
    do
        (( $#line > $max )) && max=$#line
    done
}

__spin_lock
__spinner &
for line in "${args[@]}"
do
    if ! __zpluged "$line"; then
        __die "$line: no such package\n"
        ret=1
        continue
    fi

    # Run installation in subprocess
    {
        # All variables are treated as local variable
        # because of background job (subprocess)
        local    k ret=1
        local -A zspec
        zspec=( ${(@f)"$(__parser__ "$line")"} )
        for k in ${(k)zspec}
        do
            if [[ $zspec[$k] == "-EMP-" ]]; then
                zspec[$k]=""
            fi
        done
        if [[ $zspec[from] == "local" ]]; then
            continue
        fi

        if [[ $# == 1 && $argv[1] == $zspec[name] ]]; then
            if (( $zspec[frozen] == 1 )); then
                __spin_unlock
                __put "$fg[green]$zspec[name]$reset_color: $fg[blue]frozen repo$reset_color. Update? [y/N]: "
                if read -q; then
                    __put "\n"
                    __spin_lock
                    __spinner &
                    SECONDS=0
                else
                    continue
                fi
            fi
        fi

        __spinner_echo "%-20s %s\n" \
            "Updating..." \
            $line

        function () {
            if (( $zspec[frozen] == 1 )); then
                return 3
            fi

            # Change directory to fullpath of zspec dir
            # or parent directory of zspec dir
            # If it fails, return this unnamed function with error code 2
            builtin cd -q $zspec[dir] || builtin cd -q ${zspec[dir]:h} || return 1

            # If zspec from is gh-r (GitHub Releases),
            # send a http request to git.io/releases with os argument
            # or, git pull (case of normal plugin)
            if [[ $zspec[from] == "gh-r" ]]; then
                __releases__ \
                    --of "${zspec[of]:-}" \
                    --do "${zspec[do]:-}" \
                    --at "${zspec[at]:-}" \
                    "$line" &>/dev/null
            else
                local fetch_opt
                if [[ -e $zspec[dir]/.git/shallow ]]; then
                    fetch_opt="--unshallow"
                fi
                git fetch $fetch_opt
                git checkout -q $zspec[at]

                local rev_local rev_remote rev_base
                rev_local=$(git rev-parse HEAD)
                rev_remote=$(git rev-parse "@{u}")
                rev_base=$(git merge-base HEAD "@{u}")

                if [[ $rev_local == $rev_remote ]]; then
                    # up-to-date
                    return 4
                elif [[ $rev_local = $rev_base ]]; then
                    # need to pull
                    git merge --ff-only origin/$zspec[at] && git submodule update --init --recursive
                    return $status
                elif [ $rev_remote = $rev_base ]; then
                    # need to push
                    return 1
                else
                    # Diverged
                    return 1
                fi
            fi
        } &>/dev/null
        # Return code of above unnamed function
        # Incidentally,
        # nothing is output even if it success or fails
        ret=$status

        case "$ret" in
            0)
                __spinner_echo "$fg[green]%-20s$reset_color %-${max}s\t(%.2fs)\n" \
                    "Updated!" \
                    "$line" \
                    $SECONDS

                # Update hook
                if [[ -n $zspec[do] ]]; then
                    eval "$zspec[do]"
                fi
                ;;
            1)
                __spinner_echo "$fg[red]%-20s$reset_color %-${max}s\t(%.2fs)\n" \
                    "Failed to update" \
                    "$line" \
                    $SECONDS
                ;;
            2)
                sleep 1
                __spinner_echo "$fg[magenta]%-20s$reset_color %-${max}s\t(%.2fs)\n" \
                    "Not found repo" \
                    "$line" \
                    $(( SECONDS - 1 ))
                ;;
            3)
                sleep 1
                __spinner_echo "$fg[blue]%-20s$reset_color %-${max}s\t(%.2fs)\n" \
                    "Frozen repo" \
                    "$line" \
                    $(( SECONDS - 1 ))
                ;;
            4)
                __spinner_echo "$fg[white]%-20s$reset_color %-${max}s\t(%.2fs)\n" \
                    "Up-to-date" \
                    "$line" \
                    $SECONDS
                ;;
        esac
    } &
    queue+=($!)
    if (( $#queue % queue_max == 0 )); then
        wait $queue &>/dev/null
        queue=()
    fi
done
if (( $#queue > 0 )); then
    wait $queue &>/dev/null
fi
queue=()

__spin_unlock
return $ret
